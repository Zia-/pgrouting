EXAMPLE PROCESS BASED ON WARSHALL

1. Go to the src dir
cd src

2. Make a copy of template and rename it to warshall
cp -r template warshall

3. Go to the warshall sql dir
cd warshall/sql/

4. Rename "function1.sql" to "warshall.sql"
mv function1.sql warshall.sql

5. Modify "warshall.sql" now
vi warshall.sql
	change date, name email
	-- copy old functions signature or make a new signature using this one as example (V2)
	add new function signature

6. Edit "pgr_parameter_check.sql" file in "src/common/sql" dir
cd ../../common/sql/	
vi pgr_parameter_check.sql
	-- add warshall where appropiate (because "sql" its going be the same as dijkstra, put where dikstra appears)

7. Go to "src/warshall/src" dir
cd ../../warshall/src/

8. Rename "function1.c", "function1_driver.cpp" and "function1_driver.h" files to respective warshall one in "src/warshall/src" dir
mv function1.c warshall.c
mv function1_driver.cpp warshall_driver.cpp 
mv function1_driver.h warshall_driver.h

9. Edit "warshall.c" file now
vi warshall.c
        35: change the name of the driver
	change the names of the functions
	(kind of work like the program will work)
        process starts around line 130
	153: adjust to the parameters recieved from the query
	50: and adjust to the parameters recieved from call in 153
	68: no start/end vertex check needed change to -1, -1);
	surround with #if 0 / #endif conditions that probably dont apply to the problem
	aprox 110: send the data to the cpp code (fix name and parameters)
                    // no need for rcost flag its already being used
        aprox 163: we are returning 2 bigs nd 1 float so: __pgr_2b1f
	aprox 190: fix to what we are returning

10. Edit "warshall_driver.h" now
vi warshall_driver.h
	change date, name email
	change constant of #define
	fix parameters to what its sent to us in (aprox 110)

11. And finally edit "warshall_driver.cpp" file
vi warshall_driver.cpp
	change to have  #include warshall_driver.h  (instead of function1_driver)
	surround with #if 0 / #endif conditions that probably dont apply to the problem
	change Pgr_dijkstra to Pgr_warshall  (depends on decision made in DECISION)
	addjust the calls to be: (as no start_v nor end_v are needed remove the reference to them)
        	digraph.warshall(paths) & undigraph.warshall(paths)
	The results can be stored as a deque<Path> paths  or as a Path (so I am thinking out loud)
		Warshall returns a matrix but we are going to return a table, 
		if deque<Path> paths is used then each path[i] can represent a row of the table
			anyway it will have to be collapsed to a single Path
		if Path is used then it must have all the values
        I prefer the deque<Path> paths and then do the code that is already there:
		    *ret_path = pgr_get_memory3(count, (*ret_path)); // getting memory to store the result
		    int sequence(collapse_paths(ret_path, paths));   // store the result

***** DESICION ******
For warshall we need either:
  (1)	Pgr_warshall  class defined, so we can put the functions:
		initialize_graph
		warshall
		 (and auxiliary private functions for warshall)
  (2)   Pgr_dijkstra  where we will put:
		warshall
		 (and auxiliary private functions for warshall)
For the moment I am deciding for the first one.
*********************
vi warshall_driver.cpp
	#include "./pgr_warshal.hpp"   (need to code this)

preparing a commit
cd ../../
git add warshall
git commit -a -m 'added warshall directory with connection code'


Codded pgr_warshall

1. Edit "CMakelists.txt" at "src/warshall/src/" dir 
vi CMakelists.txt
    changed function1 to warshall

2. Edit "CMakelists.txt" at "src/" dir 
vi ../../CMakelists.txt
   added in alphabetical order

   ADD_SUBDIRECTORY(warshall)
   LIST(APPEND L_PACKAGE_SQL_FILES "${PACKAGE_SQL_FILES}")

3. Edit "CMakelists.txt" at "/" dir (outermost dir) 
vi ../../../CMakelists.txt

    174: in alphabetical order:
    ${PGROUTING_SOURCE_DIR}/src/warshall/src

    261: in alphabetical order
    add_library(routing-2.1

vi ../sql/CMakelists.txt





after release 2.1
#324
Documentations says:
" is a graph analysis algorithm for finding the shortest paths between all pairs of nodes in a weighted graph"
as it does find the shortest path it does not return the shortest path, just the cost of the shortest path.
So documentation should be fixed.
